{"ast":null,"code":"import Queue from 'yocto-queue';\nexport default function pLimit(concurrency) {\n  validateConcurrency(concurrency);\n  const queue = new Queue();\n  let activeCount = 0;\n  const resumeNext = () => {\n    if (activeCount < concurrency && queue.size > 0) {\n      queue.dequeue()();\n      // Since `pendingCount` has been decreased by one, increase `activeCount` by one.\n      activeCount++;\n    }\n  };\n  const next = () => {\n    activeCount--;\n    resumeNext();\n  };\n  const run = async (function_, resolve, arguments_) => {\n    const result = (async () => function_(...arguments_))();\n    resolve(result);\n    try {\n      await result;\n    } catch {}\n    next();\n  };\n  const enqueue = (function_, resolve, arguments_) => {\n    // Queue `internalResolve` instead of the `run` function\n    // to preserve asynchronous context.\n    new Promise(internalResolve => {\n      queue.enqueue(internalResolve);\n    }).then(run.bind(undefined, function_, resolve, arguments_));\n    (async () => {\n      // This function needs to wait until the next microtask before comparing\n      // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n      // after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n      // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n      await Promise.resolve();\n      if (activeCount < concurrency) {\n        resumeNext();\n      }\n    })();\n  };\n  const generator = (function_, ...arguments_) => new Promise(resolve => {\n    enqueue(function_, resolve, arguments_);\n  });\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: () => activeCount\n    },\n    pendingCount: {\n      get: () => queue.size\n    },\n    clearQueue: {\n      value() {\n        queue.clear();\n      }\n    },\n    concurrency: {\n      get: () => concurrency,\n      set(newConcurrency) {\n        validateConcurrency(newConcurrency);\n        concurrency = newConcurrency;\n        queueMicrotask(() => {\n          // eslint-disable-next-line no-unmodified-loop-condition\n          while (activeCount < concurrency && queue.size > 0) {\n            resumeNext();\n          }\n        });\n      }\n    }\n  });\n  return generator;\n}\nexport function limitFunction(function_, option) {\n  const {\n    concurrency\n  } = option;\n  const limit = pLimit(concurrency);\n  return (...arguments_) => limit(() => function_(...arguments_));\n}\nfunction validateConcurrency(concurrency) {\n  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n    throw new TypeError('Expected `concurrency` to be a number from 1 and up');\n  }\n}","map":{"version":3,"names":["Queue","pLimit","concurrency","validateConcurrency","queue","activeCount","resumeNext","size","dequeue","next","run","function_","resolve","arguments_","result","enqueue","Promise","internalResolve","then","bind","undefined","generator","Object","defineProperties","get","pendingCount","clearQueue","value","clear","set","newConcurrency","queueMicrotask","limitFunction","option","limit","Number","isInteger","POSITIVE_INFINITY","TypeError"],"sources":["D:/Libraries/Documents/React Projects/pokemon-expectation-vs-reality/node_modules/p-limit/index.js"],"sourcesContent":["import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tvalidateConcurrency(concurrency);\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst resumeNext = () => {\n\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t\t// Since `pendingCount` has been decreased by one, increase `activeCount` by one.\n\t\t\tactiveCount++;\n\t\t}\n\t};\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tresumeNext();\n\t};\n\n\tconst run = async (function_, resolve, arguments_) => {\n\t\tconst result = (async () => function_(...arguments_))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (function_, resolve, arguments_) => {\n\t\t// Queue `internalResolve` instead of the `run` function\n\t\t// to preserve asynchronous context.\n\t\tnew Promise(internalResolve => {\n\t\t\tqueue.enqueue(internalResolve);\n\t\t}).then(\n\t\t\trun.bind(undefined, function_, resolve, arguments_),\n\t\t);\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency) {\n\t\t\t\tresumeNext();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (function_, ...arguments_) => new Promise(resolve => {\n\t\tenqueue(function_, resolve, arguments_);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue() {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t\tconcurrency: {\n\t\t\tget: () => concurrency,\n\n\t\t\tset(newConcurrency) {\n\t\t\t\tvalidateConcurrency(newConcurrency);\n\t\t\t\tconcurrency = newConcurrency;\n\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t// eslint-disable-next-line no-unmodified-loop-condition\n\t\t\t\t\twhile (activeCount < concurrency && queue.size > 0) {\n\t\t\t\t\t\tresumeNext();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nexport function limitFunction(function_, option) {\n\tconst {concurrency} = option;\n\tconst limit = pLimit(concurrency);\n\n\treturn (...arguments_) => limit(() => function_(...arguments_));\n}\n\nfunction validateConcurrency(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,aAAa;AAE/B,eAAe,SAASC,MAAMA,CAACC,WAAW,EAAE;EAC3CC,mBAAmB,CAACD,WAAW,CAAC;EAEhC,MAAME,KAAK,GAAG,IAAIJ,KAAK,CAAC,CAAC;EACzB,IAAIK,WAAW,GAAG,CAAC;EAEnB,MAAMC,UAAU,GAAGA,CAAA,KAAM;IACxB,IAAID,WAAW,GAAGH,WAAW,IAAIE,KAAK,CAACG,IAAI,GAAG,CAAC,EAAE;MAChDH,KAAK,CAACI,OAAO,CAAC,CAAC,CAAC,CAAC;MACjB;MACAH,WAAW,EAAE;IACd;EACD,CAAC;EAED,MAAMI,IAAI,GAAGA,CAAA,KAAM;IAClBJ,WAAW,EAAE;IAEbC,UAAU,CAAC,CAAC;EACb,CAAC;EAED,MAAMI,GAAG,GAAG,MAAAA,CAAOC,SAAS,EAAEC,OAAO,EAAEC,UAAU,KAAK;IACrD,MAAMC,MAAM,GAAG,CAAC,YAAYH,SAAS,CAAC,GAAGE,UAAU,CAAC,EAAE,CAAC;IAEvDD,OAAO,CAACE,MAAM,CAAC;IAEf,IAAI;MACH,MAAMA,MAAM;IACb,CAAC,CAAC,MAAM,CAAC;IAETL,IAAI,CAAC,CAAC;EACP,CAAC;EAED,MAAMM,OAAO,GAAGA,CAACJ,SAAS,EAAEC,OAAO,EAAEC,UAAU,KAAK;IACnD;IACA;IACA,IAAIG,OAAO,CAACC,eAAe,IAAI;MAC9Bb,KAAK,CAACW,OAAO,CAACE,eAAe,CAAC;IAC/B,CAAC,CAAC,CAACC,IAAI,CACNR,GAAG,CAACS,IAAI,CAACC,SAAS,EAAET,SAAS,EAAEC,OAAO,EAAEC,UAAU,CACnD,CAAC;IAED,CAAC,YAAY;MACZ;MACA;MACA;MACA;MACA,MAAMG,OAAO,CAACJ,OAAO,CAAC,CAAC;MAEvB,IAAIP,WAAW,GAAGH,WAAW,EAAE;QAC9BI,UAAU,CAAC,CAAC;MACb;IACD,CAAC,EAAE,CAAC;EACL,CAAC;EAED,MAAMe,SAAS,GAAGA,CAACV,SAAS,EAAE,GAAGE,UAAU,KAAK,IAAIG,OAAO,CAACJ,OAAO,IAAI;IACtEG,OAAO,CAACJ,SAAS,EAAEC,OAAO,EAAEC,UAAU,CAAC;EACxC,CAAC,CAAC;EAEFS,MAAM,CAACC,gBAAgB,CAACF,SAAS,EAAE;IAClChB,WAAW,EAAE;MACZmB,GAAG,EAAEA,CAAA,KAAMnB;IACZ,CAAC;IACDoB,YAAY,EAAE;MACbD,GAAG,EAAEA,CAAA,KAAMpB,KAAK,CAACG;IAClB,CAAC;IACDmB,UAAU,EAAE;MACXC,KAAKA,CAAA,EAAG;QACPvB,KAAK,CAACwB,KAAK,CAAC,CAAC;MACd;IACD,CAAC;IACD1B,WAAW,EAAE;MACZsB,GAAG,EAAEA,CAAA,KAAMtB,WAAW;MAEtB2B,GAAGA,CAACC,cAAc,EAAE;QACnB3B,mBAAmB,CAAC2B,cAAc,CAAC;QACnC5B,WAAW,GAAG4B,cAAc;QAE5BC,cAAc,CAAC,MAAM;UACpB;UACA,OAAO1B,WAAW,GAAGH,WAAW,IAAIE,KAAK,CAACG,IAAI,GAAG,CAAC,EAAE;YACnDD,UAAU,CAAC,CAAC;UACb;QACD,CAAC,CAAC;MACH;IACD;EACD,CAAC,CAAC;EAEF,OAAOe,SAAS;AACjB;AAEA,OAAO,SAASW,aAAaA,CAACrB,SAAS,EAAEsB,MAAM,EAAE;EAChD,MAAM;IAAC/B;EAAW,CAAC,GAAG+B,MAAM;EAC5B,MAAMC,KAAK,GAAGjC,MAAM,CAACC,WAAW,CAAC;EAEjC,OAAO,CAAC,GAAGW,UAAU,KAAKqB,KAAK,CAAC,MAAMvB,SAAS,CAAC,GAAGE,UAAU,CAAC,CAAC;AAChE;AAEA,SAASV,mBAAmBA,CAACD,WAAW,EAAE;EACzC,IAAI,EAAE,CAACiC,MAAM,CAACC,SAAS,CAAClC,WAAW,CAAC,IAAIA,WAAW,KAAKiC,MAAM,CAACE,iBAAiB,KAAKnC,WAAW,GAAG,CAAC,CAAC,EAAE;IACtG,MAAM,IAAIoC,SAAS,CAAC,qDAAqD,CAAC;EAC3E;AACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}